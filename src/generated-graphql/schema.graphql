schema {
  query: Query
  mutation: Mutation
}

"""Exposes a URL that specifies the behaviour of this scalar."""
directive @specifiedBy(
  """The URL that specifies the behaviour of this scalar."""
  url: String!
) on SCALAR

type Query {
  """Get account balance tree"""
  accountBalances: AccountBalancesResponse!
  accountHierarchy(userId: String!): AccountHierarchyResponse!
  changed: ChangedResponse!
  charts(userId: String!): ChartsResponse!
  """Get context for a specific entry"""
  context(entryHash: String!): ContextResponse!
  editorData: EditorDataResponse!
  """Extract entries using the ingest framework"""
  extract(filename: String!, importer: String!): ExtractResponse!
  """Check if the Fava service is healthy"""
  favaHealth: HealthResponse!
  featureFlags(userId: String!): JSONObject!
  """is the server healthy?"""
  health: String!
  homeCharts(userId: String!): HomeChartsResponse!
  isPaid: IsPaidResponse!
  """Get journal entries with enhanced search, filtering, and pagination"""
  journalEntries(
    """Account regex filter (e.g., 'Assets:*' or 'Expenses:Food:*')"""
    accountFilter: String
    """Cursor for pagination (can be date string YYYY-MM-DD or index)"""
    after: String
    """Maximum amount filter for transactions"""
    amountMax: Float
    """Minimum amount filter for transactions"""
    amountMin: Float
    """Cursor for pagination (can be date string YYYY-MM-DD or index)"""
    before: String
    """Whether to include detailed entry metadata"""
    detailed: Boolean
    """Entry types to include (Transaction, Balance, Open, Close, etc.)"""
    entryTypes: [String!]
    """Number of entries to fetch from the start"""
    first: Int
    """Group entries by: date, account, payee"""
    groupBy: String
    """Number of entries to fetch from the end"""
    last: Int
    """Text search across payee, narration, and account fields"""
    searchQuery: String
    """Sort field: date, amount, payee, account"""
    sortBy: String
    """Sort order: asc or desc"""
    sortOrder: String
  ): JournalEntriesResponse!
  ledgerMeta(userId: String!): LedgerMetaResponse!
  """get the ledger of the current user"""
  ledgers(file: BeanFilename): [Ledger!]
  listOutboundIntegrations: ListOutboundIntegrationsResponse!
  """Get ranked accounts for a given payee"""
  payeeAccounts(payee: String!): PayeeAccountsResponse!
  """Get the last transaction for a given payee"""
  payeeTransaction(payee: String!): PayeeTransactionResponse!
  paymentHistory: [Receipt!]!
  """Execute a Beancount query and get results"""
  queryResult(queryString: String!): QueryResultResponse!
  subscriptionStatus: CustomerSubscriptionStatus!
  """get the user"""
  userProfile(userId: String): UserProfileResponse
}

type AccountBalancesResponse {
  data: TreeNode!
  success: Boolean!
}

type TreeNode {
  account: String!
  balance: JSONObject!
  balance_children: JSONObject!
  children: [TreeNode!]!
}

"""The `JSONObject` scalar type represents JSON objects as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf)."""
scalar JSONObject

type AccountHierarchyResponse {
  data: [LabeledHierarchyItem!]!
  success: Boolean!
}

type LabeledHierarchyItem {
  data: AccountBalance!
  label: String!
  type: String!
}

type AccountBalance {
  account: String!
  balance: JSONObject!
  balance_children: JSONObject!
  children: [AccountBalance!]!
}

type ChangedResponse {
  data: Boolean!
  success: Boolean!
}

type ChartsResponse {
  data: [ChartItem!]!
  success: Boolean!
}

type ChartItem {
  balance: Balance!
  budgets: JSONObject
  date: String!
}

type Balance {
  USD: Float
}

type ContextResponse {
  data: Context!
  success: Boolean!
}

type Context {
  content: String!
  sha256sum: String!
  slice: [Int!]!
}

type EditorDataResponse {
  data: EditorData!
  success: Boolean!
}

type EditorData {
  file_path: String!
  sha256sum: String!
  source: String!
  sources: [String!]!
}

type ExtractResponse {
  data: [JSONObject!]!
  success: Boolean!
}

type HealthResponse {
  data: String!
  success: Boolean!
}

type HomeChartsResponse {
  data: [LabeledChartItem!]!
  success: Boolean!
}

type LabeledChartItem {
  data: [ChartItemV2!]!
  label: String!
  type: String!
}

type ChartItemV2 {
  balance: JSONObject!
  budgets: JSONObject
  date: String!
}

type IsPaidResponse {
  isForcedToPay: Boolean
  isPaid: Boolean
}

type JournalEntriesResponse {
  data: [JournalEntry!]!
  """Pagination information"""
  pageInfo: PageInfo
  success: Boolean!
}

type JournalEntry {
  account: String
  """Amount for balance entries"""
  amount: PostingUnits
  booking: String
  comment: String
  currencies: [String!]
  date: String!
  entry_hash: String
  entry_type: String
  error: String
  error_message: String
  filename: String
  flag: String
  links: [String]
  meta: EntryMeta!
  narration: String
  """Net amount for the transaction"""
  netAmount: Float
  payee: String
  postings: [JournalEntryPosting!]
  """Primary account for display"""
  primaryAccount: String
  """Combined searchable text"""
  searchableText: String
  tags: [String]
  """Entry type (Transaction, Balance, Open, etc.)"""
  type: String!
}

type PostingUnits {
  currency: String!
  number: Float!
}

type EntryMeta {
  filename: String!
  lineno: Float!
}

type JournalEntryPosting {
  account: String!
  cost: String
  flag: String
  meta: PostingMeta
  price: String
  units: PostingUnits
}

type PostingMeta {
  filename: String!
  lineno: Float!
}

type PageInfo {
  """Cursor for the end of the current page"""
  endCursor: String
  """Whether there are more entries after the current page"""
  hasNextPage: Boolean!
  """Whether there are more entries before the current page"""
  hasPreviousPage: Boolean!
  """Cursor for the start of the current page"""
  startCursor: String
  """Total number of entries available"""
  totalCount: Int
}

type LedgerMetaResponse {
  data: LedgerMeta!
  success: Boolean!
}

type LedgerMeta {
  accounts: [String!]!
  currencies: [String!]!
  errors: Float!
  options: Options!
}

type Options {
  name_assets: String!
  name_equity: String!
  name_expenses: String!
  name_income: String!
  name_liabilities: String!
  operating_currency: [String!]!
}

"""valid filename string"""
scalar BeanFilename

type Ledger {
  file: BeanFilename!
  ledgerId: String!
  text: String!
}

type ListOutboundIntegrationsResponse {
  integrations: [OutboundIntegration!]
}

type OutboundIntegration {
  id: String!
  providerId: String!
}

type PayeeAccountsResponse {
  data: [String!]!
  success: Boolean!
}

type PayeeTransactionResponse {
  data: JSONObject!
  success: Boolean!
}

type Receipt {
  _id: String
  amount: String!
  chargeId: String
  createAt: DateTime
  currency: String!
  estimatedIotx: Float
  fulfilledHash: String
  paymentEmail: String!
  userId: String!
}

"""The javascript `Date` as string. Type represents date and time as the ISO Date string."""
scalar DateTime

type QueryResultResponse {
  data: QueryResult!
  success: Boolean!
}

type QueryResult {
  chart: JSONObject
  table: String!
}

type CustomerSubscriptionStatus {
  hasActiveSubscription: Boolean!
  subscriptions: [Subscription!]!
}

type Subscription {
  cancelAt: DateTime
  cancelAtPeriodEnd: Boolean!
  canceledAt: DateTime
  clientId: String!
  currentPeriodEnd: DateTime!
  currentPeriodStart: DateTime!
  id: ID!
  items: [SubscriptionItem!]!
  status: String!
}

type SubscriptionItem {
  id: ID!
  price: SubscriptionPrice!
  product: SubscriptionProduct
  quantity: Float!
}

type SubscriptionPrice {
  amount: Float!
  currency: String!
  id: ID!
  interval: String!
  intervalCount: Float
  trialPeriodDays: Float
}

type SubscriptionProduct {
  description: String
  id: ID!
  images: [String!]
  name: String!
}

type UserProfileResponse {
  email: String!
  emailReportStatus: ReportStatus
  id: String!
  locale: String!
}

"""The email report status"""
enum ReportStatus {
  MONTHLY
  OFF
  WEEKLY
}

type Mutation {
  addEntries(entriesInput: [EntryInput!]!): AddEntryResponse!
  addPushToken(token: String!): Boolean!
  """Attach a document to an entry"""
  attachDocument(attachInput: AttachDocumentInput!): DocumentOperationResponse!
  cancelSubscription(clientId: String!, subscriptionId: String!): SubscriptionActionResult!
  """Create or rename a file"""
  createOrRenameFile(fileInput: CreateOrRenameFileInput!): FileOperationResponse!
  createOutboundIntegration(byAuthorizationCode: ByAuthorizationCode): CreateOutboundIntegrationResponse!
  createSubscriptionSession(clientId: String!, priceId: String!): SubscriptionSessionResult!
  """Delete a document"""
  deleteDocument(filename: String!): DocumentOperationResponse!
  """Delete a Fava file"""
  deleteFavaFile(deleteInput: DeleteFavaFileInput!): FileOperationResponse!
  """delete file that belongs to the user."""
  deleteFile(deleteFileRequest: DeleteFileRequest!): DeleteFileResponse
  deleteOutboundIntegration(byIntegration: DeleteOutboundIntegrationByIntegration): DeleteOutboundIntegrationResponse!
  """Format beancount source code"""
  formatSource(source: String!): SourceUpdateResponse!
  """Move a document file to a different account"""
  moveDocument(moveInput: MoveDocumentInput!): MoveResponse!
  """rename file that belongs to the user. returns null if no file found."""
  renameFile(renameFileRequest: RenameFileRequest!): Ledger
  sendPushNotification(data: JSONObject!, message: String!, pushToken: String!): Boolean!
  """update or insert user report subscribe status"""
  updateReportSubscribe(status: ReportStatus!, userId: String!): UpdateReportSubscribeResponse
  """Update source file content"""
  updateSource(sourceInput: SourceInput!): SourceUpdateResponse!
  """Update entry source slice"""
  updateSourceSlice(sourceSliceInput: SourceSliceInput!): SourceUpdateResponse!
  """update or insert a ledger text"""
  upsertLedger(file: BeanFilename!, text: String): Ledger
}

input EntryInput {
  date: String!
  flag: String!
  meta: JSONObject!
  narration: String!
  payee: String!
  postings: [PostingInput!]!
  type: String!
}

input PostingInput {
  account: String!
  amount: String!
}

type AddEntryResponse {
  data: String
  success: Boolean!
}

input AttachDocumentInput {
  entry_hash: String!
  filename: String!
}

type DocumentOperationResponse {
  data: String!
  success: Boolean!
}

type SubscriptionActionResult {
  message: String
  success: Boolean!
}

input CreateOrRenameFileInput {
  ledger_id: String!
  new_file: String!
  old_file: String
}

type FileOperationResponse {
  data: String!
  success: Boolean!
}

input ByAuthorizationCode {
  code: String!
  providerId: String!
}

type CreateOutboundIntegrationResponse {
  _: Boolean!
}

type SubscriptionSessionResult {
  message: String
  sessionId: String
  sessionUrl: String
  success: Boolean!
}

input DeleteFavaFileInput {
  filename: String!
  ledger_id: String!
}

input DeleteFileRequest {
  file: BeanFilename!
  ledgerId: String!
}

type DeleteFileResponse {
  _id: ID
}

input DeleteOutboundIntegrationByIntegration {
  integrationId: String!
}

type DeleteOutboundIntegrationResponse {
  _: Boolean!
}

type SourceUpdateResponse {
  data: String!
  success: Boolean!
}

input MoveDocumentInput {
  account: String!
  filename: String!
  newName: String!
}

type MoveResponse {
  data: String!
  success: Boolean!
}

input RenameFileRequest {
  from: String!
  ledgerId: String!
  to: String!
}

type UpdateReportSubscribeResponse {
  success: Boolean!
}

input SourceInput {
  file_path: String!
  sha256sum: String!
  source: String!
}

input SourceSliceInput {
  entry_hash: String!
  sha256sum: String!
  source: String!
}
